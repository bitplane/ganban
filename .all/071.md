# computed properties

Split `load_board` into data loading and activation so computed properties have a clean home. This is foundational — deps, labels, label editor, and dependency graph all depend on having a reliable computed property system that survives board merges.

If we don't get the architecture right we'll fight it on every feature and accumulate branching logic.

**_load_tree(repo, tree)** — pure deserialization of the ganban branch:

* board sections + meta (index.md)
* cards + meta (.all/*.md)
* columns + links (N.slug/)

Nothing derived. Just what's on the branch.

**_activate(board, repo)** — computed properties + watchers:

* git: committers, config (currently bolted on at end of load_board)
* card-level: blocked state from deps (card 025), labels (card 001)
* column-level: (future)

Watchers set up here must survive `board.update(new_board)` during sync merges. New cards/columns added at runtime need to get wired in via watchers on the card/column lists.

**what needs to work:**

* load_board returns a fully activated board with all computed props
* sync reload via board.update() preserves watchers, computed props stay consistent
* adding/removing cards at runtime wires/unwires their computed props
* the pattern is extensible — adding a new computed property means adding one function in activate, not touching every call site

**blockers:** none, but card 025 (deps), card 001 (labels), card 053 (dep graph), card 006 (label editor) all depend on this.
